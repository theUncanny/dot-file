let g:is_windows = has('win32')
let g:is_cygwin = has('win32unix')
let g:is_mac = !g:is_windows
      \ && (has('mac') || has('macunix') || has('gui_macvim') ||
      \   (!isdirectory('/proc') && executable('sw_vers')))

" Load vim-plug
if !g:is_windows && empty(glob($HOME . "/.vim/autoload/plug.vim"))
  :silent !mkdir -p ~/.vim/autoload >/dev/null 2>&1
  :silent !curl -fLo ~/.vim/autoload/plug.vim https://raw.github.com/junegunn/vim-plug/master/plug.vim >/dev/null 2>&1
endif

call plug#begin('~/.vim/plugged')
Plug 'tpope/vim-sensible'
Plug 'bling/vim-airline'
Plug 'Lokaltog/vim-easymotion'
Plug 'Yggdroot/indentLine'
Plug 'christoomey/vim-tmux-navigator'
Plug 'jgdavey/tslime.vim'
Plug 'ctrlpvim/ctrlp.vim', { 'on': 'CtrlP' }
Plug 'FelikZ/ctrlp-py-matcher', { 'on': 'CtrlP' }
Plug 'majutsushi/tagbar', {'on': 'TagbarToggle'}
Plug 'scrooloose/nerdtree', {'on': 'NERDTreeToggle'}
Plug 'sjl/gundo.vim', {'on': 'GundoToggle'}
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-fugitive'
Plug 'AndrewRadev/splitjoin.vim'
Plug 'Raimondi/delimitMate'
Plug 'bronson/vim-trailing-whitespace'
Plug 'tpope/vim-commentary'
"Plug 'tpope/vim-abolish'
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-projectionist'
Plug 'mattn/emmet-vim'

Plug 'vim-scripts/fcitx.vim', { 'on': 'Fcitx' }

Plug 'Shougo/neosnippet.vim'
Plug 'ervandew/supertab'
Plug 'honza/vim-snippets'

Plug 'tpope/vim-unimpaired'
Plug 'jeetsukumaran/vim-buffergator'

Plug 'benekastah/neomake'
Plug 'janko-m/vim-test'

Plug 'sheerun/vim-polyglot'
Plug 'tpope/vim-rails', { 'for': ['ruby', 'haml', 'eruby'] }
Plug 'ecomba/vim-ruby-refactoring', { 'on': 'RubyRefactoring' }

Plug 'tomasr/molokai'
Plug 'morhetz/gruvbox'
Plug 'ryanoasis/vim-devicons'
call plug#end()

" http://stackoverflow.com/a/9528322
" Save your backups to a less annoying place than the current directory.
" If you have .vim-backup in the current directory, it'll use that.
" Otherwise it saves it to ~/.vim/_backup or . if all else fails.
if isdirectory($HOME . '/.vim/_backup') == 0
  :silent !mkdir -p ~/.vim/_backup >/dev/null 2>&1
endif
set backupdir-=.
set backupdir+=.
set backupdir-=~/
set backupdir^=~/.vim/_backup/
set backupdir^=./.vim-backup/
set backup

" Save your swp files to a less annoying place than the current directory.
" If you have .vim-swap in the current directory, it'll use that.
" Otherwise it saves it to ~/.vim/_temp, ~/tmp or .
if isdirectory($HOME . '/.vim/_temp') == 0
  :silent !mkdir -p ~/.vim/_temp >/dev/null 2>&1
endif
set directory=./.vim-swap//
set directory+=~/.vim/_temp//
set directory+=~/tmp//
set directory+=.

" viminfo stores the the state of your previous editing session
set viminfo+=n~/.vim/viminfo

if exists("+undofile")
  " undofile - This allows you to use undos after exiting and restarting
  " This, like swap and backups, uses .vim-undo first, then ~/.vim/_undo
  " :help undo-persistence
  " This is only present in 7.3+
  if isdirectory($HOME . '/.vim/_undo') == 0
    :silent !mkdir -p ~/.vim/_undo > /dev/null 2>&1
  endif
  set undodir=./.vim-undo//
  set undodir+=~/.vim/_undo//
  set undofile
endif

let mapleader = " "
set nowrap " don't wrap lines
set tabstop=2 " a tab is two spaces
set shiftwidth=2 " an autoindent (with <<) is two spaces
set expandtab " use spaces, not tabs
set list " Show invisible characters
set hlsearch " highlight matches
set ignorecase " searches are case insensitive...
set smartcase " ... unless they contain at least one capital letter

set mouse=a " Enable mouse support
set mousemodel=popup " Right click behavior like MS
set cc=+1 " Color column textwidth + 1

set shiftround

set ttyfast
set lazyredraw
set timeout timeoutlen=1000 ttimeoutlen=100
set synmaxcol=300

" Natural split
set splitbelow
set splitright

" Special chars
if (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8') && version >= 700
  let &listchars = "tab:\u21e5\u00b7,trail:\u2423,extends:\u21c9,precedes:\u21c7,nbsp:\u26ad"
  let &fillchars = "vert:\u2502,fold:\u00b7"
else
  set listchars=tab:>\ ,trail:-,extends:>,precedes:<
endif

" Disable output and VCS files
set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem
" Disable archive files
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
" Ignore bundler and sass cache
set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
" Ignore librarian-chef, vagrant, test-kitchen and Berkshelf cache
set wildignore+=*/tmp/librarian/*,*/.vagrant/*,*/.kitchen/*,*/vendor/cookbooks/*
" Ignore rails temporary asset caches
set wildignore+=*/tmp/cache/assets/*/sprockets/*,*/tmp/cache/assets/*/sass/*
" Disable temp and backup files
set wildignore+=*.swp,*~,._*

if has("autocmd")
  " Remember last location in file, but not for commit messages.
  " see :help last-position-jump
  au BufReadPost * if &filetype !~ '^git\c' && line("'\"") > 0 && line("'\"") <= line("$")
        \| exe "normal! g`\"" | endif
endif

" easy move between windows
nore <silent> <C-K> :wincmd k<CR>
nore <silent> <C-J> :wincmd j<CR>
nore <silent> <C-H> :wincmd h<CR>
nore <silent> <C-L> :wincmd l<CR>

" Adjust viewports to the same size
nore <Leader>= <C-w>=

" Toggle paste mode
nnore <silent> <F4> :set invpaste<CR>:set paste?<CR>
inore <silent> <F4> <ESC>:set invpaste<CR>:set paste?<CR>

" format the entire file
nnoremap <leader>fef :normal! gg=G``<CR>

" Some helpers to edit mode
" http://vimcasts.org/e/14
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>

" Underline the current line with '='
nnore <silent> <leader>ul :t.<CR>Vr=

" Map the arrow keys to be based on display lines, not physical lines
nore <Down> gj
nore <Up> gk

" clear highlight
nnore <leader><CR> :noh<CR>

nore ; :
nore \ ;
inore jk <Esc>
inore kj <Esc>

" Sane regex
nnoremap / /\v
vnoremap / /\v

" Tslime
let g:tslime_always_current_session = 1
let g:tslime_always_current_window = 1
vmap <C-c><C-c> <Plug>SendSelectionToTmux
nmap <C-c><C-c> <Plug>NormalModeSendToTmux
nmap <C-c>r <Plug>SetTmuxVars

" Neomake
autocmd! BufWritePost * Neomake
let g:neomake_ruby_enabled_makers = ['mri']

" vim-test
nmap <silent> <leader>t :TestNearest<CR>
nmap <silent> <leader>T :TestFile<CR>
nmap <silent> <leader>a :TestSuite<CR>
nmap <silent> <leader>l :TestLast<CR>
nmap <silent> <leader>g :TestVisit<CR>
let test#strategy = "tslime"

" vim-buffergator
let g:buffergator_suppress_keymaps = 1
nmap <silent> <leader>to :BuffergatorTabsOpen<CR>
nmap <silent> <leader>b :BuffergatorOpen<CR>

" Markdown
let g:markdown_fenced_languages = ['coffee', 'css', 'erb=eruby.html',
      \ 'javascript', 'json=javascript', 'ruby', 'sass', 'html', 'sh']

" Liquid
let g:liquid_highlight_types = g:markdown_fenced_languages +
      \ ['html+erb=eruby.html']

" ctrlp setting {
let g:ctrlp_map = ''
let g:ctrlp_clear_cache_on_exit = 0
if !has('python')
  echo 'In order to use pymatcher plugin, you need +python compiled vim'
else
  let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif
let g:ctrlp_custom_ignore = {
      \ 'dir': '\v[\/]\.(git|hg|svn)$',
      \ 'file': '\.pyc$\|\.pyo$\|\.rbc$|\.rbo$\|\.class$\|\.o$\|\~$\',
      \ }
" If ag is available use it as filename list generator instead of 'find'
if executable("ag")
  set grepprg=ag\ --nogroup\ --nocolor
  let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup
        \ --ignore ''.git''
        \ --ignore ''.DS_Store''
        \ --ignore ''node_modules''
        \ --hidden -g ""'
endif
" }

" NEARDTree {
let NERDTreeIgnore=['\.pyc$', '\.pyo$', '\.rbc$', '\.rbo$', '\.class$', '\.o$', '\~$']

augroup AuNERDTreeCmd
autocmd AuNERDTreeCmd VimEnter * call s:CdIfDirectory(expand("<amatch>"))
autocmd AuNERDTreeCmd FocusGained * call s:UpdateNERDTree()

" If the parameter is a directory, cd into it
function! s:CdIfDirectory(directory)
  let explicitDirectory = isdirectory(a:directory)
  let directory = explicitDirectory || empty(a:directory)

  if explicitDirectory
    exe "cd " . fnameescape(a:directory)
  endif

  " Allows reading from stdin
  " ex: git diff | mvim -R -
  if strlen(a:directory) == 0
    return
  endif

  if directory
    NERDTree
    wincmd p
    bd
  endif

  if explicitDirectory
    wincmd p
  endif
endfunction

" NERDTree utility function
function! s:UpdateNERDTree(...)
  let stay = 0

  if(exists("a:1"))
    let stay = a:1
  end

  if exists("t:NERDTreeBufName")
    let nr = bufwinnr(t:NERDTreeBufName)
    if nr != -1
      exe nr . "wincmd w"
      exe substitute(mapcheck("R"), "<CR>", "", "")
      if !stay
        wincmd p
      end
    endif
  endif
endfunction
" }

" DelimitMate
let g:delimitMate_expand_cr = 1
let g:delimitMate_expand_space = 1
let delimitMate_excluded_ft = "markdown" " disable for markdown

" Tagbar mappings.
nore <Leader>rc :TagbarToggle<CR>

" NEARDTree
nore <leader>n :NERDTreeToggle<CR> :NERDTreeMirror<CR>

" gundo {
nnore <F5> :GundoToggle<CR>
inore <F5> <ESC>:GundoToggle<CR>
" }

" git fugitive {
nnore <leader>gb :Gblame<CR>
nnore <leader>gs :Gstatus<CR>
nnore <leader>gd :Gdiff<CR>
nnore <leader>gl :Glog<CR>
nnore <leader>gc :Gcommit<CR>
nnore <leader>gp :Git push<CR>
nnore <leader>gw :Gwrite<CR>
" }

nore <Leader>p :CtrlP<CR>

" split join
let g:splitjoin_split_mapping = 'ss'
let g:splitjoin_join_mapping  = 'sj'

" Airline
let g:airline#extensions#tagbar#enabled = 0
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1
let g:airline_mode_map = {
      \ '__' : '-',
      \ 'n'  : 'N',
      \ 'i'  : 'I',
      \ 'R'  : 'R',
      \ 'c'  : 'C',
      \ 'v'  : 'V',
      \ 'V'  : 'V',
      \ '' : 'V',
      \ 's'  : 'S',
      \ 'S'  : 'S',
      \ '' : 'S',
      \ }

" sets the arglist to contain each of the files referenced by the quickfix list
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

" Neosnippet {
" Use <C-Space>
imap <C-Space> <C-@>
imap <C-@>     <Plug>(neosnippet_expand_or_jump)
smap <C-@>     <Plug>(neosnippet_expand_or_jump)
xmap <C-@>     <Plug>(neosnippet_expand_target)
let g:neosnippet#enable_snipmate_compatibility = 1
" }

" Vim-devicons
autocmd FileType nerdtree setlocal nolist

" SuperTab
let g:SuperTabDefaultCompletionType = "context"

" Ruby completion
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_rails = 1

" Language setting
autocmd FileType * if exists("+omnifunc") && &omnifunc == "" | setlocal omnifunc=syntaxcomplete#Complete | endif
autocmd FileType * if exists("+completefunc") && &completefunc == "" | setlocal completefunc=syntaxcomplete#Complete | endif

autocmd FileType php setlocal tabstop=4 shiftwidth=4
autocmd FileType php let b:delimitMate_eol_marker = ";"

autocmd FileType ruby setlocal tw=79 isfname+=:
autocmd FileType liquid,markdown,text,txt setlocal tw=78 linebreak nolist

let g:rehash256 = 1
colorscheme molokai
