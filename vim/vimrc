let g:is_windows = has('win33')

" Load vim-plug
if !g:is_windows && empty(glob($HOME . "/.vim/autoload/plug.vim"))
  :silent !mkdir -p ~/.vim/autoload >/dev/null 2>&1
  :silent !curl -fLo ~/.vim/autoload/plug.vim https://raw.github.com/junegunn/vim-plug/master/plug.vim >/dev/null 2>&1
endif

call plug#begin('~/.vim/plugged')

" file management
Plug 'ctrlpvim/ctrlp.vim', { 'on': 'CtrlP' }
Plug 'FelikZ/ctrlp-py-matcher', { 'on': 'CtrlP' }
Plug 'tpope/vim-eunuch'
Plug 'scrooloose/nerdtree', {'on': 'NERDTreeToggle'}

" git
Plug 'tpope/vim-fugitive'

" textedit
Plug 'AndrewRadev/splitjoin.vim'
Plug 'Raimondi/delimitMate'
Plug 'terryma/vim-multiple-cursors'
Plug 'bronson/vim-trailing-whitespace'
Plug 'junegunn/vim-easy-align'
Plug 'haya14busa/incsearch.vim'
Plug 'tpope/vim-commentary'

Plug 'tpope/vim-sensible'
Plug 'Yggdroot/indentLine'
Plug 'christoomey/vim-tmux-navigator'
Plug 'jgdavey/tslime.vim'
Plug 'majutsushi/tagbar', {'on': 'TagbarToggle'}
Plug 'sjl/gundo.vim', {'on': 'GundoToggle'}
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-projectionist'
Plug 'mattn/emmet-vim'
Plug 'vim-scripts/fcitx.vim', { 'on': 'Fcitx' }
Plug 'MarcWeber/vim-addon-mw-utils'| Plug 'tomtom/tlib_vim' | Plug 'garbas/vim-snipmate'
Plug 'ervandew/supertab'

Plug 'benekastah/neomake', { 'on': ['Neomake'] }
Plug 'janko-m/vim-test', { 'on': ['TestFile', 'TestLast', 'TestNearest', 'TestSuite', 'TestVisit'] }

Plug 'sheerun/vim-polyglot'

Plug 'tpope/vim-rails', { 'for': ['ruby', 'haml', 'eruby'] }
Plug 'ecomba/vim-ruby-refactoring', { 'on': ['RAddParameter', 'RInlineTemp',
      \ 'RConvertPostConditional', 'RExtractConstant', 'RExtractLet',
      \ 'RExtractLocalVariable', 'RRenameLocalVariable',
      \ 'RRenameInstanceVariable', 'RExtractMethod'] }

" colorscheme
Plug 'reedes/vim-colors-pencil'
Plug 'tomasr/molokai'
Plug 'morhetz/gruvbox'
Plug 'sjl/badwolf'

Plug 'junegunn/goyo.vim'

if filereadable(expand("~/.vimplug.local"))
  source ~/.vimplug.local
endif
call plug#end()

if isdirectory($HOME . '/.vim/_temp') == 0
  :silent !mkdir -p ~/.vim/_temp >/dev/null 2>&1
endif
set directory=./.vim-swap//
set directory+=~/.vim/_temp//
set directory+=~/tmp//
set directory+=.

if has('nvim')
  set viminfo+=n~/.config/nvim/nvim.shada
else
  set viminfo+=n~/.vim/viminfo
endif

if exists("+undofile")
  if isdirectory($HOME . '/.vim/_undo') == 0
    :silent !mkdir -p ~/.vim/_undo > /dev/null 2>&1
  endif
  set undodir=./.vim-undo//
  set undodir+=~/.vim/_undo//
  set undofile
endif

let mapleader = " "
set nowrap " don't wrap lines
set tabstop=8
set softtabstop=2 " a tab is two spaces
set shiftwidth=2 " an autoindent (with <<) is two spaces
set shiftround
set expandtab " use spaces, not tabs
set list " Show invisible characters
set hlsearch " highlight matches
set ignorecase " searches are case insensitive...
set smartcase " ... unless they contain at least one capital letter

set relativenumber

set mouse=n " Enable mouse support
set cc=+1 " Color column textwidth + 1

set ttyfast
set lazyredraw
set timeout timeoutlen=500 ttimeoutlen=50
set synmaxcol=300

" Natural split
set splitbelow
set splitright

" Special chars
if (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8') && version >= 700
  let &listchars = "tab:\u21e5\u00b7,trail:\u2423,extends:\u21c9,precedes:\u21c7,nbsp:\u26ad"
  let &fillchars = "vert:\u2502,fold:\u00b7"
else
  set listchars=tab:>\ ,trail:-,extends:>,precedes:<
endif

" Disable output and VCS files
set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem
" Disable archive files
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
" Ignore bundler and sass cache
set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
" Ignore librarian-chef, vagrant, test-kitchen and Berkshelf cache
set wildignore+=*/tmp/librarian/*,*/.vagrant/*,*/.kitchen/*,*/vendor/cookbooks/*
" Ignore rails temporary asset caches
set wildignore+=*/tmp/cache/assets/*/sprockets/*,*/tmp/cache/assets/*/sass/*
" Disable temp and backup files
set wildignore+=*.swp,*~,._*

augroup restore_position
  autocmd!
  " Remember last location in file, but not for commit messages.
  " see :help last-position-jump
  au BufReadPost * if &filetype !~ '^git\c' && line("'\"") > 0 && line("'\"") <= line("$")
        \| exe "normal! g`\"" | endif
augroup END

" easy move between windows
nore <silent> <C-K> :wincmd k<CR>
nore <silent> <C-J> :wincmd j<CR>
nore <silent> <C-H> :wincmd h<CR>
nore <silent> <C-L> :wincmd l<CR>

" Adjust viewports to the same size
nore <Leader>= <C-w>=

" Toggle paste mode
nnore <silent> <F4> :set invpaste<CR>:set paste?<CR>
inore <silent> <F4> <ESC>:set invpaste<CR>:set paste?<CR>

" format the entire file
nnoremap <leader>fef :normal! gg=G``<CR>

" Some helpers to edit mode
" http://vimcasts.org/e/14
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>

" Map the arrow keys to be based on display lines, not physical lines
nore <Down> gj
nore <Up> gk

" clear highlight
nnore <leader><CR> :noh<CR>

inore jk <Esc>
inore kj <Esc>

" incsearch.vim
map /  <Plug>(incsearch-forward)\v
map ?  <Plug>(incsearch-backward)\v
map g/ <Plug>(incsearch-stay)\v

let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)

" Tslime
let g:tslime_always_current_session = 1
let g:tslime_always_current_window = 1
vmap <C-c><C-c> <Plug>SendSelectionToTmux
nmap <C-c><C-c> <Plug>NormalModeSendToTmux
nmap <C-c>r <Plug>SetTmuxVars

" Neomake
autocmd! BufWritePost * Neomake
if !has('nvim')
  let g:neomake_ruby_enabled_makers = ['mri']
endif

" vim-test
nmap <silent> <leader>t :TestNearest<CR>
nmap <silent> <leader>T :TestFile<CR>
nmap <silent> <leader>a :TestSuite<CR>
nmap <silent> <leader>l :TestLast<CR>
nmap <silent> <leader>g :TestVisit<CR>
let test#strategy = "tslime"

" vim-buffergator
let g:buffergator_suppress_keymaps = 1
nmap <silent> <leader>to :BuffergatorTabsOpen<CR>
nmap <silent> <leader>b :BuffergatorOpen<CR>

" Markdown
let g:markdown_fenced_languages = ['coffee', 'css', 'erb=eruby.html',
      \ 'javascript', 'json=javascript', 'ruby', 'sass', 'html', 'sh']

" Liquid
let g:liquid_highlight_types = g:markdown_fenced_languages +
      \ ['html+erb=eruby.html']

" ctrlp setting {
let g:ctrlp_map = ''
let g:ctrlp_clear_cache_on_exit = 0
if has('python')
  let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif
let g:ctrlp_custom_ignore = {
      \ 'dir': '\v[\/]\.(git|hg|svn)$',
      \ 'file': '\.pyc$\|\.pyo$\|\.rbc$|\.rbo$\|\.class$\|\.o$\|\~$\',
      \ }
" If ag is available use it as filename list generator instead of 'find'
if executable("ag")
  set grepprg=ag\ --nogroup\ --nocolor
  let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup
        \ --ignore ''.git''
        \ --ignore ''.DS_Store''
        \ --ignore ''node_modules''
        \ --ignore ''vendor/plugins''
        \ --hidden -g ""'
  let g:ctrlp_use_caching = 0
endif
" }

" NEARDTree {
let NERDTreeIgnore=['\.pyc$', '\.pyo$', '\.rbc$', '\.rbo$', '\.class$', '\.o$', '\~$']
" }

" DelimitMate
let g:delimitMate_expand_cr = 1
let g:delimitMate_expand_space = 1
let delimitMate_balance_matchpairs = 1
let delimitMate_excluded_ft = "markdown" " disable for markdown

" Tagbar mappings.
nore <Leader>rc :TagbarToggle<CR>

" NEARDTree
nore <leader>n :NERDTreeToggle<CR> :NERDTreeMirror<CR>

" gundo {
nnore <F5> :GundoToggle<CR>
inore <F5> <ESC>:GundoToggle<CR>
" }

" git fugitive {
nnore <leader>gb :Gblame<CR>
nnore <leader>gg :Ggrep <C-R><C-W><CR>
" }

nore <Leader>p :CtrlP<CR>

" split join
let g:splitjoin_split_mapping = ''
let g:splitjoin_join_mapping = ''
nmap <Leader>j :SplitjoinJoin<cr>
nmap <Leader>s :SplitjoinSplit<cr>

" sets the arglist to contain each of the files referenced by the quickfix list
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" vim-multiple-cursors
let g:multi_cursor_exit_from_visual_mode=0
let g:multi_cursor_exit_from_insert_mode=0

" goyo
let s:save_background = ""
let s:save_color = ""
function! s:goyo_before()
    if !has("gui_running")
        return
    endif
    let is_mark_or_rst = &filetype == "markdown" || &filetype == "rst" || &filetype == "text"

    if is_mark_or_rst
        let s:save_background = &background
        let s:save_color = g:colors_name
        set linespace=8
        set background=light
        colorscheme pencil
    endif
endfunction

function! s:goyo_after()
    if !has("gui_running")
        return
    endif
    let is_mark_or_rst = &filetype == "markdown" || &filetype == "rst" || &filetype == "text"
    if is_mark_or_rst
        set linespace=0

        exec( "set background=" . s:save_background )
        exec( "colorscheme " . s:save_color )
    endif
endfunction

let g:goyo_callbacks = [ function('s:goyo_before'), function('s:goyo_after') ]

" vim-rails
let g:rails_projections = {
      \   "app/serializers/*_serializer.rb": {
      \     "command":   "serializer",
      \     "affinity":  "model",
      \     "test":      "spec/serializers/{}_spec.rb",
      \     "related":   "app/models/{}.rb",
      \     "template":  "class {camelcase|capitalize|colons}Serializer < ActiveModel::Serializer\nend"
      \   },
      \   "app/decorators/*_decorator.rb": {
      \     "command": "decorator",
      \     "affinity": "model",
      \     "test": "spec/decorators/%s_spec.rb",
      \     "related": "app/models/%s.rb",
      \     "template": "class %SDecorator < Draper::Decorator\nend"
      \   },
      \   "test/factories/*.rb": {
      \     "command":   "factory",
      \     "affinity":  "collection",
      \     "alternate": "app/models/{singular}.rb",
      \     "related":   "db/schema.rb#{}",
      \     "test":      "test/models/{singular}_test.rb",
      \     "template":  "FactoryGirl.define do\n  factory :{singular} do\n  end\nend",
      \     "keywords":  "factory sequence"
      \   },
      \   "spec/factories/*.rb": {
      \     "command":   "factory",
      \     "affinity":  "collection",
      \     "alternate": "app/models/{singular}.rb",
      \     "related":   "db/schema.rb#{}",
      \     "test":      "spec/models/{singular}_test.rb",
      \     "template":  "FactoryGirl.define do\n  factory :{singular} do\n  end\nend",
      \     "keywords":  "factory sequence"
      \   }
      \ }

" Ruby completion
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_rails = 1

" Language setting
let ruby_no_expensive=1
set regexpengine=1
augroup language_settings
  autocmd!
  autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
  autocmd FileType liquid,markdown,text,txt setlocal tw=78 linebreak nolist spell
augroup END

if !exists('g:colors_name')
  let g:rehash256 = 1
  " colorscheme molokai
  let g:badwolf_darkgutter = 1
  colorscheme badwolf
endif

if filereadable(expand("~/.vimrc.local"))
  source ~/.vimrc.local
endif
